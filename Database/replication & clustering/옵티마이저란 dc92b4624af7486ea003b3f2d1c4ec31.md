# 옵티마이저란?

태그: 데이터베이스

**📌✔**

## **옵티마이저란?**

개발자가 작성한 SQL을 어떻게 실행할 것인지 실행계획을 수립하고 SQL을 실행하게 되는데, 실행계획의 수립을 맡아서 수행

> **📌** SQL을 가장 빠르고 효율적으로 수행할 최적의 쿼리 경로를 생성해주는 DBMS 내부 엔진
> 

## **📌 실행 계획 (Execution Plan)**

데이터 딕셔너리에 있는 오브젝트 통계, 시스템 통계 등의 정보를 사용해서 예상되는 비용을 평가하여 여러 실행계획을 세우고 **해당 비용을 연산하고 가장 낮은 비용을 가진 실행계획을 선택**

### **✔ 쿼리 처리 흐름 - 개발자가 쿼리를 실행하면 옵티마이저는 언제 실행 계획을 작성할까?!**

![스크린샷 2023-07-14 오후 11.21.28.png](%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%85%E1%85%A1%E1%86%AB%20dc92b4624af7486ea003b3f2d1c4ec31/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-07-14_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_11.21.28.png)

1. 개발자가 SQL문을 작성
2. 파서(Parser)는 개발자가 작성한 SQL문을 문법 검사와 구문 분석을 진행
3. 옵티마이저는 여러 플랜을 생성, 카탈로그 매니저에 있는 각종 통계정보를 기반으로 비용을 평가하여 최소 비용의 실행계획을 결정함
4. SQL 실행 엔진이 옵티마이저가 결정한 실행계획대로 데이터처리하여 사용자에게 전달

> 옵티마이저 실행 방법엔 **규칙기반 옵티마이저 / 비용기반 옵티마이저**가 있음
> 
> 
> 대부분의 관계형 데이터베이스는 보통 **비용기반 옵티마이저**만을 제공함.
> 

## **규칙기반(RBO) / 비용기반 (CBO) 옵티마이저**

1. **규칙기반 Rule based obtimizer**
    - 실행 속도가 빠른 순으로 규칙을 세워두고 우선순위가 높은 방법을 채택하는 옵티마이저
    - 규칙 = 액세스 경로별 우선순위로서, 인덱스 구조, 연산, 조건절 형태가 순위를 결정 지음
    - 🔑 `규칙 우선순위`
        1. ROWID를 사용한 단일 행인경우
        2. 클러스터 조인에 의한 단일행
        3. 유일하거나 기본키를 가진 해시 클러스터 키에 의한 단일행인 경우
        4. 유일하거나 기본키에 의한 단일행인경우
        5. 클러스터 조인인경우
        6. 해시 클러스터 조인인경우
        7. 인덱스 클러스터 키인 경우
        8. 복합 컬럼 인덱스인경우
        9. 단일 컬럼 인덱스 인경우
        10. 인덱스가 구성된 칼럼에서 제한된 범위를 검색하는 경우
    
2. **비용 기반 Cost based obtimizer**
    - 규칙기반 옵티마이저의 단점을 극복하기 위해 출현
    - SQL문을 처리하는데 필요한 비용이 가장 적은 실행계획을 선택함
    - 계산하는 `비용`, SQL문을 처리하기 위해 `예상되는 소요시간 / 자원 사용량`
        - 비용 = 예상치 : 테이블, 인덱스,칼럼 등 다양한 객체 통계정보 및 시스템 통계정보 ( CPU 속도, 디스크 I/O 속도 등)을 이용함

## **📌 옵티마이저의 최적화 목표**

### (1) 전체 처리 속도 최적화

- 쿼리 최종 결과집합을 끝까지 읽는 것을 전제, 시스템 리소스를 가장 적게 사용하는 실행계획을 세움
- 대부분의 DBMS의 기본 옵티마이저 모드는 전체 처리속도 최적화에 맞춰져있음

### (2) 최초 응답속도 최적화

- 전체 결과 집합중, 일부만 읽다가 멈추는 것을 전제, 가장 빠른 응답 속도를 낼 수 있는 실행계획을 선택
- 만약, 이 모드에서 생성한 실행계획으로 데이터를 끝까지 읽는다면, 전체 처리 속도 최적화 실행계획보다 더 많은 리소스를 사용하고 수행속도도 느려짐

## **📌 옵티마이저 행동에 영향을 미치는 요소**

1. SQL과 연산자 형태
2. 옵티마이징 팩터
    - 쿼리 구성은 같아도, Index,IOT,클러스터링,파티셔닝 등의 구성에 따라 달라짐
3. DBMS 제약 설정
    - 개체 무결성, 참조 무결성, 도메인 무결성을 위해 DBMS에서 제공하는 PK,FK,Check,Not Null 같은 제약 설정 기능을 이용
        - *예시 ) 인덱스 칼럼에 Not Null 제약이 설정되어있으면 옵티마이저는 전체개수를 구하는 Count 쿼리에 이 인덱스를 활용할 수 있음*
            - 내 생각.. *(Null인 데이터가 없으니 Count를 세기에 적합하다고 판단하나..?*
4. 옵티마이저 힌트 : 사용자가 지정한 옵티마이저 힌트
5. 통계 정보
- 세부 통계정
    
    ![스크린샷 2023-07-16 오전 2.21.09.png](%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%90%E1%85%B5%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%84%85%E1%85%A1%E1%86%AB%20dc92b4624af7486ea003b3f2d1c4ec31/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-07-16_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_2.21.09.png)
    
    1. 옵티마이저 관련 파라미터 
        - DBMS 버전을 업그레이드하면 다르게 작동 ! ( 옵티마이저 관련 파라미터가 추가 또는 변경되기때문)
    2. DBMS 버전과 종류 
        - 버전에 따라 내부적으로 처리하는 방식이 다를 수 있음

### **📌  옵티마이저의 한계**

> 옵티마이저가 비효율적으로 동작하고 있다면, 오라클의 힌트와 같은 부가적인 장치로 올바르게 작동하도록 유도해야함
> 

**✔옵티마이저가 완벽하지 못하게 만드는 요인**

1. 옵티마이징 팩터의 부족
    - 효가적으로 구성된 인덱스, IOT, 클러스터링, 파티셔닝 등이 필요
2. 통계정보의 부정확성
    - 100% 정확한 통계정보를 유지하기 어렵기때문에,
    - 특히 칼럼 분포가 고르지 않을때 칼럼 히스토그램이 반드시 필요한데, 이를 수집하고 유지하는 비용이 큼.
    - 칼럼을 결합했을때 모든 결합 분포를 미리 구해두기도 어려움.
    - 따라, 상관관계에 있는 두 칼럼이 조건절에 사용될때 옵티마이저가 잘모된 실행계획을 수립하게 만드는 주 요인임
3. 바인드 변수 사용시 균등 분포 가정
    - 조건절에 바인드 변수를 사용하면, 옵티마이저가 균등분포를 가정하고 비용을 계산함 ( 정확한 칼럼 히스토그램을 가지고 있더라도 !! )
4. 비현실적인 가정
    - 쿼리 수행 비용을 평가시 여러 가정을 사용함, 그 일부는 상당히 비현실적이라 종종 이해할 수 없는 실행계획을 수립
    - 예시) 예전 Oracle 버전에선 single block I/O와 Multiblock I/O의 비용을 같게 평가하고 데이터 블록의 캐싱 효과도 고려하지 않았었음.
    - 해당 부분은 DBMS 버전이 올라가면서 계속 보완되고 있지만, 완벽히 해결되진 않으므로
5. 규칙에 의존하는 CBO
    - 예시) 최적화 목표를 최초 응답속도에 맞추면 order by 소트를 대체할 인덱스가 있을때 무조건 그 인덱스를 사용함
6. 하드웨어 성능
    - 옵티마이저 개발팀이 사용한 하드웨어 사양에 맞춰져있음.
    - 따라, 실제 운영 시스템의 하드웨어 사양이 그것과 다를때 잘못된 실행계획을 수립할 가능성이 높아짐
    - 어플리케이션 특성(I/O 패턴, 부하정도) 등에 의해서도 하드웨어 성능은 달라짐

### **✔** 머신러닝에서의 옵티마이저

- 머신러닝의 성능 개선법=옵티마이징 (최적화 - optimization )
- 사실 DB와 머신러닝, 딥러닝에서 말하는 옵티마이저의 궁극적인 목적은 동일할 것이다.

> **DB에서 최소의 코스트로 결과를 찾는 개념과 신경망의 모델이 실제 결과와 예측 결과의 차이를 최소화 시키는 것은 어찌보면 동일**
> 

🔗 [https://zangzangs.tistory.com/103](https://zangzangs.tistory.com/103)

🔗[https://code-lab1.tistory.com/137](https://code-lab1.tistory.com/137)

🔗[https://needjarvis.tistory.com/685](https://needjarvis.tistory.com/685)