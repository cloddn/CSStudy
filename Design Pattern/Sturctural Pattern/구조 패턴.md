# 구조 패턴

태그: 디자인 패턴
부가 태그: 정처기

**📌✔**

# #구조 패턴

> 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
> 
> 
> 예시 ) 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴
> 

## **📌 구조 패턴의 특징**

- 서로 독립적으로 개발한 클래스 라이브러리를 마치 하나인 것처럼 사용할 수 있음
- 여러 인터페이스를 합성하여 서로 다른 인터페이스들의 통일된 추상을 제공함
- 인터페이스나 구현을 복합하는 것이 아니라 객체를 합성하는 방법을 제공함

## **📌 구조 패턴의 종류**

1. 어댑터 패턴 Adapter Pattern 
    - 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록, 타 클래스의 인터페이스를 기존 인터페이스에 덧씌운다
2. 브리지 패턴 Bridge Pattern
    - 추상화와 구현을 분리해 둘을 각각 따로 발전 시킬 수 있음
3. 합성 패턴 Composite Pattern
    - 0개 1개 혹은 그 이상의 객체를 묶어 하나의 객체로 이용할 수 있음
4. 데코레이터 패턴 Decorator Pattern
    - 기존 객체의 메서드에 새로운 행동을 추가하거나 오버라이드할 수 있음
5. 퍼사드 패턴 Pacade Pattern
    - 많은 분량의 코드에 접근할 수있는 단순한 인터페이스를 제공
6. 플라이웨이트 패턴 Flyweight Pattern 
    - 다수의 유사한 객체를 생성,조작하는 비용을 절감할 수 있음
7. 프록시 패턴 Proxy Pattern
    - 접근 조절, 비용 절감, 복잡도 감소를 위해 접근이 힘든 객체를 위한 대역을 제공

### **✔ (1) 구조 패턴 - 어댑터 패턴(Adapter Pattern)**

- 어댑터 패턴이란?
    - 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해주는 패턴이 어댑터 패턴
    - 어댑터 역할을 하는 클래스를 새롭게 만들어야함
    - 기존에 있는 시스템에 써드파티 라이브러리가 추가된다던지, 레거시 인터페이스를 새로운 인터페이스로 교체하는 경우에 코드의 재사용성을 높일 수 있는 방법이 어댑터 패턴을 사용하는 것
        - **레거시** : 정보기술에서, 레거시 프로그램과 데이터는 프로그래밍 언어, 플랫폼 그리고 기술 등에 있어, 과거로 부터 물려 내려온 것들을 의미한다. 컴퓨터를 사용하는 대부분의 기업들은 중요한 업무를 처리하는 레거시 응용프로그램들과 데이터베이스를 가지고 있다.
- 어댑터 패턴 장점
    - 관계가 없는 인터페이스간 같이 사용 가능
    - 프로그램 검사 용이
    - 클래스 재활용성 증가
- 어댑터 패턴 구조
    
    ![images-ha0kim-post-29e02c14-de86-457d-b9e3-1a7325e800c5-image.png](%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%209cd9c808e59747b590d180d5864f679e/images-ha0kim-post-29e02c14-de86-457d-b9e3-1a7325e800c5-image.png)
    
    1. Client : 써드파티 라이브러리나 외부시스템을 사용하려는 쪽이다.
    2. Adaptee : 써드파티 라이브러리나 외부시스템을 의미한다.
    3. Target Interface : Adapter 가 구현(implements) 하는 인터페이스이다.
        
        클라이언트는 Target Interface 를 통해 Adaptee 인 써드파티 라이브러리를 사용하게 된다.
        
    4. Adapter : Client 와 Adaptee 중간에서 호환성이 없는 둘을 연결시켜주는 역할을 담당한다.
        
        Target Interface 를 구현하며, 클라이언트는 Target Interface 를 통해 어댑터에 요청을 보낸다.
        
        어댑터는 클라이언트의 요청을 Adaptee 가 이해할 수 있는 방법으로 전달하고 처리는 Adaptee 에서 이루어진다.
        
- 어댑터 패턴 호출 과정
    
    ![images-ha0kim-post-decd0bb3-88f8-40fd-aadf-d155b9217630-image.png](%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%209cd9c808e59747b590d180d5864f679e/images-ha0kim-post-decd0bb3-88f8-40fd-aadf-d155b9217630-image.png)
    
    - 클라이언트는 Target Interface를 호출하는 것처럼 보임
    - 하지만 클라이언트의 요청을 전달받은 target interface를 구현한 Adapter는 자신이 감싸고 있는 Adaptee에게 실질적인 처리를 위임함
    - Adater가 Adaptee를 감싸고 있는 것때문에 Wrapper 패턴이라고도 불림

### **✔ (2) 구조 패턴 - 브리지 패턴(Bridge Pattern)**

- 브리지 패턴이란?
    - 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴
    - 즉, 추상적 개념과 구체적 구현을 서로 다른 두개의 인터페이스로 구현하는 디자인 패턴
    - 캡슐화 (Encapsulation) , 집합 (Aggregation)을 사용하고, 또한 다른 클래스들로 책임을 분리시키기위해 상속 (Inheritance)를 사용할 수 있음
- 브리지 패턴 장점
    - 인터페이스와 구현이 분리됨
    - 서로 독립적으로 확장할 수 있음
    - 구현 세부사항을 클라이언트에게 은닉하여 캡슐화를 지킬 수 있음
- 브리지 패턴 구조
    
    ![images-ha0kim-post-a579bd3e-82e6-4bfb-ae3a-5bd14429c3fc-image.png](%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%209cd9c808e59747b590d180d5864f679e/images-ha0kim-post-a579bd3e-82e6-4bfb-ae3a-5bd14429c3fc-image.png)
    
    1. Abstraction
        - 기능 계층의 최상위 클래스이며 추상 인터페이스를 정의한다.
        - Implementor에 대한 레퍼런스를 유지한다.
        - 구현 부분에 해당하는 클래스를 인스턴스를 가지고 해당 인스턴스를 통해 구현부분의 메서드를 호출한다.
    2. RefinedAbstraction
        - Abstraction에 의해 정의된 인터페이스를 확장한다.(extends)
        - 기능 계층에서 새로운 부분을 확장한 클래스이다.
    3. Implementor
        - 구현 클래스를 위한 인터페이스를 정의한다.
        - Abstraction의 기능을 구현하기 위한 인터페이스 정의한다.
    4. ConcreteImplementor
        - Implementor 인터페이스를 구현 즉, 실제 기능을 구현한다.

### **✔ (3) 구조 패턴 - 합성 패턴(Composite Pattern)**

- 합성 패턴이란?
    - 객체들의 관계를 트리구조로 구성하여 전체-부분 계층을 표현하는 패턴으로 여러 개의 겍체들로 구성한 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 함
    - 즉, 전체-부분의 관계 (ex: Directory-File)를 갖는 객체들 사이의 관계를 정의할때 융요함
    - 또한 클라이언트는 전체와 부분을 구분하지 않고, 동일한 인터페이스를 사용할 수 있음
- 합성 패턴 구조
    
    ![images-ha0kim-post-3f0a909d-1d25-4aa3-98f8-419adfb301b7-image.png](%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%209cd9c808e59747b590d180d5864f679e/images-ha0kim-post-3f0a909d-1d25-4aa3-98f8-419adfb301b7-image.png)
    
1. Component
    - Leaf와 Composite를 같은 타입으로 취급하기 위한 인터페이스.
    - Leaf 클래스와 전체에 해당하는 Composite 클래스에 공통 인터페이스를 정의한다.
2. Leaf
    - 구체적인 부분 클래스로 단일 객체를 표현한다.
    - 그룹의 구성원 역할을 하며 트리구조로 따지면 가장 밑단에 존재하는 나뭇잎 역할을 한다고 보면 된다.
3. Composite
    - 복합 객체 그룹을 표현할 클래스로 전체 클래스이다.
    - 자식으로 여러개의 Component 타입 멤버를 수용할 수 있도록 구현되어야 한다.

### **✔ (4) 구조 패턴 - 데코레이터 패턴(Decorator Pattern)**

- 데코레이터 패턴이란?
    - 객체의 결합을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴
    - 객체에 추가적인 요건을 동적으로 첨가하며 기능 확장이 필요할때 서브 클래싱 대신 쓸 수 있는 유연한 대안이 될 수 있다
    - 즉, 기본 기능에 추가할 수 있는 기능의 종류가 많은 경우에 각 추가 기능을 Decorator 클래스에 정의한 후 필요한 Decorator 객체에를 조합함으로서 추가 기능의 조합을 설계하는 방식
- 데코레이터 패턴 구조
    
    ![images-ha0kim-post-92d9a3f1-bf77-45d5-93ad-e04cea72a940-image.png](%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%209cd9c808e59747b590d180d5864f679e/images-ha0kim-post-92d9a3f1-bf77-45d5-93ad-e04cea72a940-image.png)
    
1. Component
    - ConcreteComponent 과 Decorator가 구현할 인터페이스다.
    - 두 객체를 동등하게 다루기 위해 존재한다.
2. ConcreteComponent
    - Decorate를 받을 객체다.
    - 즉, 기능 추가를 받을 기본 객체이다.
3. Decorator
    - Decorate를 할 객체의 추상 클래스다.
    - 즉, 기능 추가를 할 객체는 이 객체를 상속받는다.
4. ConcreteDecorator
    - Decorator를 상속받아 구현할 다양한 기능 객체이다.
    - 이 기능들은 ConcreteComponent에 추가되기 위해 만들어 진다.

🔗 [https://velog.io/@ha0kim/Design-Pattern-구조-패턴Structural-Patterns](https://velog.io/@ha0kim/Design-Pattern-%EA%B5%AC%EC%A1%B0-%ED%8C%A8%ED%84%B4Structural-Patterns) 

🔗 [https://arabiannight.tistory.com/129](https://arabiannight.tistory.com/129)