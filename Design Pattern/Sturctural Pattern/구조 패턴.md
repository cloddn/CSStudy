# 구조 패턴

태그: 디자인 패턴
부가 태그: 정처기

**📌✔**

# #구조 패턴

> 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
> 
> 
> 예시 ) 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴
> 

## **📌 구조 패턴의 특징**

- 서로 독립적으로 개발한 클래스 라이브러리를 마치 하나인 것처럼 사용할 수 있음
- 여러 인터페이스를 합성하여 서로 다른 인터페이스들의 통일된 추상을 제공함
- 인터페이스나 구현을 복합하는 것이 아니라 객체를 합성하는 방법을 제공함

## **📌 구조 패턴의 종류**

1. 어댑터 패턴 Adapter Pattern 
    - 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록, 타 클래스의 인터페이스를 기존 인터페이스에 덧씌운다
2. 브리지 패턴 Bridge Pattern
    - 추상화와 구현을 분리해 둘을 각각 따로 발전 시킬 수 있음
3. 합성 패턴 Composite Pattern
    - 0개 1개 혹은 그 이상의 객체를 묶어 하나의 객체로 이용할 수 있음
4. 데코레이터 패턴 Decorator Pattern
    - 기존 객체의 메서드에 새로운 행동을 추가하거나 오버라이드할 수 있음
5. 퍼사드 패턴 Pacade Pattern
    - 많은 분량의 코드에 접근할 수있는 단순한 인터페이스를 제공
6. 플라이웨이트 패턴 Flyweight Pattern 
    - 다수의 유사한 객체를 생성,조작하는 비용을 절감할 수 있음
7. 프록시 패턴 Proxy Pattern
    - 접근 조절, 비용 절감, 복잡도 감소를 위해 접근이 힘든 객체를 위한 대역을 제공

### **✔ (1) 구조 패턴 - 어댑터 패턴(Adapter Pattern)**

- 어댑터 패턴이란?
    - 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해주는 패턴이 어댑터 패턴
    - 어댑터 역할을 하는 클래스를 새롭게 만들어야함
    - 기존에 있는 시스템에 써드파티 라이브러리가 추가된다던지, 레거시 인터페이스를 새로운 인터페이스로 교체하는 경우에 코드의 재사용성을 높일 수 있는 방법이 어댑터 패턴을 사용하는 것
        
        <aside>
        ✏️ Q. **레거시란?**
        
        A. 정보기술에서, 레거시 프로그램과 데이터는 프로그래밍 언어, 플랫폼 그리고 기술 등에 있어, 과거로 부터 물려 내려온 것들을 의미한다. 컴퓨터를 사용하는 대부분의 기업들은 중요한 업무를 처리하는 레거시 응용프로그램들과 데이터베이스를 가지고 있다.
        
        </aside>
        
    
- 어댑터 패턴 장점
    - 관계가 없는 인터페이스간 같이 사용 가능
    - 프로그램 검사 용이
    - 클래스 재활용성 증가
- 어댑터 패턴 구조
    
    ![images-ha0kim-post-29e02c14-de86-457d-b9e3-1a7325e800c5-image.png](%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%209cd9c808e59747b590d180d5864f679e/images-ha0kim-post-29e02c14-de86-457d-b9e3-1a7325e800c5-image.png)
    
    1. Client : 써드파티 라이브러리나 외부시스템을 사용하려는 쪽이다.
    2. Adaptee : 써드파티 라이브러리나 외부시스템을 의미한다.
    3. Target Interface : Adapter 가 구현(implements) 하는 인터페이스이다.
        
        클라이언트는 Target Interface 를 통해 Adaptee 인 써드파티 라이브러리를 사용하게 된다.
        
    4. Adapter : Client 와 Adaptee 중간에서 호환성이 없는 둘을 연결시켜주는 역할을 담당한다.
        
        Target Interface 를 구현하며, 클라이언트는 Target Interface 를 통해 어댑터에 요청을 보낸다.
        
        어댑터는 클라이언트의 요청을 Adaptee 가 이해할 수 있는 방법으로 전달하고 처리는 Adaptee 에서 이루어진다.
        
- 어댑터 패턴 호출 과정
    
    ![images-ha0kim-post-decd0bb3-88f8-40fd-aadf-d155b9217630-image.png](%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%209cd9c808e59747b590d180d5864f679e/images-ha0kim-post-decd0bb3-88f8-40fd-aadf-d155b9217630-image.png)
    
    - 클라이언트는 Target Interface를 호출하는 것처럼 보임
    - 하지만 클라이언트의 요청을 전달받은 target interface를 구현한 Adapter는 자신이 감싸고 있는 Adaptee에게 실질적인 처리를 위임함
    - Adater가 Adaptee를 감싸고 있는 것때문에 Wrapper 패턴이라고도 불림

### **✔ (2) 구조 패턴 - 브리지 패턴(Bridge Pattern)**

- 브리지 패턴이란?
    - 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴
    - 즉, 추상적 개념과 구체적 구현을 서로 다른 두개의 인터페이스로 구현하는 디자인 패턴
    - 캡슐화 (Encapsulation) , 집합 (Aggregation)을 사용하고, 또한 다른 클래스들로 책임을 분리시키기위해 상속 (Inheritance)를 사용할 수 있음
- 브리지 패턴 장점
    - 인터페이스와 구현이 분리됨
    - 서로 독립적으로 확장할 수 있음
    - 구현 세부사항을 클라이언트에게 은닉하여 캡슐화를 지킬 수 있음
- 브리지 패턴 구조
    
    ![images-ha0kim-post-a579bd3e-82e6-4bfb-ae3a-5bd14429c3fc-image.png](%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%209cd9c808e59747b590d180d5864f679e/images-ha0kim-post-a579bd3e-82e6-4bfb-ae3a-5bd14429c3fc-image.png)
    
    1. Abstraction
        - 기능 계층의 최상위 클래스이며 추상 인터페이스를 정의한다.
        - Implementor에 대한 레퍼런스를 유지한다.
        - 구현 부분에 해당하는 클래스를 인스턴스를 가지고 해당 인스턴스를 통해 구현부분의 메서드를 호출한다.
    2. RefinedAbstraction
        - Abstraction에 의해 정의된 인터페이스를 확장한다.(extends)
        - 기능 계층에서 새로운 부분을 확장한 클래스이다.
    3. Implementor
        - 구현 클래스를 위한 인터페이스를 정의한다.
        - Abstraction의 기능을 구현하기 위한 인터페이스 정의한다.
    4. ConcreteImplementor
        - Implementor 인터페이스를 구현 즉, 실제 기능을 구현한다.

### **✔ (3) 구조 패턴 - 합성 패턴(Composite Pattern)**

- 합성 패턴이란?
    - 객체들의 관계를 트리구조로 구성하여 전체-부분 계층을 표현하는 패턴으로 여러 개의 겍체들로 구성한 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루게 함
    - 즉, 전체-부분의 관계 (ex: Directory-File)를 갖는 객체들 사이의 관계를 정의할때 융요함
    - 또한 클라이언트는 전체와 부분을 구분하지 않고, 동일한 인터페이스를 사용할 수 있음
- 합성 패턴 구조
    
    ![images-ha0kim-post-3f0a909d-1d25-4aa3-98f8-419adfb301b7-image.png](%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%209cd9c808e59747b590d180d5864f679e/images-ha0kim-post-3f0a909d-1d25-4aa3-98f8-419adfb301b7-image.png)
    
1. Component
    - Leaf와 Composite를 같은 타입으로 취급하기 위한 인터페이스.
    - Leaf 클래스와 전체에 해당하는 Composite 클래스에 공통 인터페이스를 정의한다.
2. Leaf
    - 구체적인 부분 클래스로 단일 객체를 표현한다.
    - 그룹의 구성원 역할을 하며 트리구조로 따지면 가장 밑단에 존재하는 나뭇잎 역할을 한다고 보면 된다.
3. Composite
    - 복합 객체 그룹을 표현할 클래스로 전체 클래스이다.
    - 자식으로 여러개의 Component 타입 멤버를 수용할 수 있도록 구현되어야 한다.

### **✔ (4) 구조 패턴 - 데코레이터 패턴(Decorator Pattern)**

- 데코레이터 패턴이란?
    - 객체의 결합을 통해 기능을 동적으로 유연하게 확장 할 수 있게 해주는 패턴
    - 객체에 추가적인 요건을 동적으로 첨가하며 기능 확장이 필요할때 서브 클래싱 대신 쓸 수 있는 유연한 대안이 될 수 있다
    - 즉, 기본 기능에 추가할 수 있는 기능의 종류가 많은 경우에 각 추가 기능을 Decorator 클래스에 정의한 후 필요한 Decorator 객체에를 조합함으로서 추가 기능의 조합을 설계하는 방식
- 데코레이터 패턴 구조
    
    ![images-ha0kim-post-92d9a3f1-bf77-45d5-93ad-e04cea72a940-image.png](%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%209cd9c808e59747b590d180d5864f679e/images-ha0kim-post-92d9a3f1-bf77-45d5-93ad-e04cea72a940-image.png)
    
1. Component
    - ConcreteComponent 과 Decorator가 구현할 인터페이스다.
    - 두 객체를 동등하게 다루기 위해 존재한다.
2. ConcreteComponent
    - Decorate를 받을 객체다.
    - 즉, 기능 추가를 받을 기본 객체이다.
3. Decorator
    - Decorate를 할 객체의 추상 클래스다.
    - 즉, 기능 추가를 할 객체는 이 객체를 상속받는다.
4. ConcreteDecorator
    - Decorator를 상속받아 구현할 다양한 기능 객체이다.
    - 이 기능들은 ConcreteComponent에 추가되기 위해 만들어 진다.
    - 

### **✔ (5) 구조 패턴 - 퍼사드 패턴(Facade Pattern)**

- 퍼사드 패턴이란?
    - 건물의 정면을 의미하는 단어로 어떤 소프트웨어의 다른 커다란 코드 부분에 대하여 간략화된 인터페이스를 제공하주는 디자인 패턴
    - 퍼사드 객체는 복잡한 소프트웨어 바깥쪽의 코드가 라이브러리의 안쪽 코드에 의존하는 일을 감소시켜주고 복잡한 소프트웨어를 사용할 수 있게 간단한 인터페이스를 제공함
- 퍼사드 패턴 장점
    1. 퍼사드는 소프트웨어 라이브러리를 쉽게 사용/ 쉽게 이해 할 수 있게 해줌
        - 공통적인 작업에 대해 간편한 메소드를 제공함
    2. 퍼사드는 라이브러리를 사용하는 코드들을 좀 더 읽기 쉽게 해줌
    3. 퍼사드는 라이브러리 바깥쪽의 코드가 라이브러리의 안쪽 코드에 의존하는 일을 감소시켜줌
        - 대부분의 바깥쪽 코드가 퍼사드를 이용하기때문에 시스템을 개발하는데에 있어 유연성이 향상됨
    4. 퍼사드는 좋게 작성되지않은 API의 집합을 하나의 좋게 작성된 API로 감싸줌

- 퍼사드 패턴 구조
    
    ![images-ha0kim-post-872ae831-e69b-41e1-be48-8bb6ba8e447e-image.png](%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%209cd9c808e59747b590d180d5864f679e/images-ha0kim-post-872ae831-e69b-41e1-be48-8bb6ba8e447e-image.png)
    
    1. Facade
        
        퍼사드 클래스는 패키지 및 그 밖의 응용 프로그램 코드와 상호 동작한다.
        
    2. Client
        
        패키지 내의 리소스들을 접근하기 위해 퍼사드 클래스를 쓰는 객체들이다.
        
    3. Package (SubSystem Class)
        
        소프트웨어 라이브러리 / API 집합이다. 퍼사드 클래스를 통해 접근된다.
        

### **✔ (6) 구조 패턴 - 플라이웨이트 패턴(Flyweight Pattern)**

- 플라이웨이트 패턴이란?
    - 어떤 클래스의 인스턴스 한 개만 가지고 여러 개의 “ 가상 인스턴스”를 제공하고 싶을때 사용하는 패턴
    - 즉 , 인스턴스를 가능한 대로 공유시켜 쓸데없이 new 연산자를 통한 메모리 낭비를 줄이는 방식
    - 주로 생성된 객체 수를 줄이고 메모리 사용 공간을 줄이며 성능을 향상시키는 데 사용되며, 이러한 유형의 디자인 패턴은 오브젝트 패턴을 감소시켜 어플리케이션에 필요한 오브젝트 구조를 향상시킴
- 플라이웨이트 패턴 적용이 적합한 경우
    1. 어플리케이션에 의해 생성되는 객체의 수가 많아야 한다.
    2. 생성된 객체가 오래도록 메모리에 상주하며 사용되는 횟수가 많다.
    3. 객체의 특성을 내적 속성(Intrinsic Properties)과 외적 속성(Extrinsic Properties)으로 나눴을 때, 객체의 외적 특성이 클라이언트 프로그램으로부터 정의되어야 한다.
        
        <aside>
        ✏️ Q. 내적속성과 외적 속성이란?
        
        A. 객체의 내적 속성은 객체를 유니크하게 하는 것이고, 외적 속성은 클라이언트의 코드로부터 설정되어 다른 동작을 수행하도록 사용되는 특성이다. 예를 들어, Circle 이라는 객체는 color와 width라는 외적 속성을 가질 수 있다.
        
        </aside>
        

### **✔ (7) 구조 패턴 - 프록시 패턴(Proxy Pattern)**

- 프록시 패턴이란?
    - 실제 기능을 수행하는 객체(Real Object) 대신 가상의 객체(Proxy Object)를 사용해 로직의 흐름을 제어하는 디자인 패턴
    - 프록시 패턴을 사용하는 경우는 어떤 클래스의 객체 생성이 오래 걸리는 경우 그 일을 분업을 하여 proxy 클래스에서 처리 할 수 있는 부분은 처리를 하고 proxy 클래스에서 처리 할 수 없는 작업에 대해서만 실제 클래스의 객체를 생성하고 위임하는 방식을 취함.
    - RealSubject가 원격 시스템에서 돌아가거나 그 객체의 생성 비용이 많이 들어 실제 사용 시점에 객체를 생성하거나 실제 객체에 접근을 제한 및 제어를 해야 할 때 등 의 경우에 사용됨
- 프록시 패턴 특징
    1. 원래 하려던 기능을 수행하며 그외의 부가적인 작업(로깅, 인증, 네트워크 통신 등)을 수행할 수 있다.
    2. 비용이 많이 드는 연산(DB 쿼리, 대용량 텍스트 파일 등)을 실제로 필요한 시점에 수행할 수 있다.
    3. 실제 객체의 리소스가 무거운 경우, 프록시 객체에서 간단한 처리를 하거나 기본 객체를 캐싱 처리함으로써 부하를 줄일 수 있다.
    4. 실제 객체에 대한 수정 없이 클라이언트에서의 사용과 기본 객체 사이에 일련의 로직을 프록시 객체를 통해 넣을 수 있다.
    5. 프록시는 기본 객체와 요청 사이에 있기 때문에 일종의 방패(보안)의 역할도 한다.
    6. 사용자 입장에서는 프록시 객체나 실제 객체나 사용법이 유사하므로 구조나 코드 구현이 간단하다.
- ✏️ **`프록시 패턴 종류`**
    1. 원격 프록시 : 원격 객체에 대한 접근 제어가 가능하다.
    2. 가상 프록시 (Virtual Proxy) : 객체의 생성비용이 많이 들어 미리 생성하기 힘든 객체에 대한 접근 및 생성시점 등을 제어한다.
    3. 보호 프록시 (Protection Proxy) : 객체에 따른 접근 권한을 제어해야하는 객체에 대한 접근을 제어한다.
    4. 방화벽 프록시 : 일련의 네트워크 자원에 대한 접근을 제어함으로써 주 객체를 '나쁜' 클라이언트들로부터 보호한다.
    5. 스마트 레퍼런스 프록시 (Smart Reference Proxy) : 주 객체가 참조될 때마다 추가 행동을 제공한다.
        
        ex) 객체 참조에 대한 선 작업, 후 작업 등
        
    6. 캐싱 프록시 (Caching Proxy) : 비용이 많이 드는 작업의 결과를 임시로 저장 하고, 추후 여러 클라이언트에 저장된 결과를 실제 작업처리 대신 보여주고 자원을 절약한다.
    7. 동기화 프록시 (Synchronization Proxy) : 여러 스레드에서 주 객체에 접근하는 경우에 안전하게 작업을 처리한다. 주로 분산 환경에서 일련의 객체에 대한 동기화 된 접근을 제어해주는 자바 스페이스에서 사용된다.
    8. 복잡도 숨김 프록시 (Complexity Hiding Proxy) : 복잡한 클래스들의 집합에 대한 접근을 제어하고, 복잡도를 숨긴다.
    9. 지연 복사 프록시 (Copy-On-Write Proxy) : 클라이언트에서 필요로 할 때까지 객체가 복사되는 것을 지연시킴으로써 객체의 복사를 제어한다.
        
        '변형된 가상 프록시'라고 할 수 있으며, Java 5 의 CopyOnWriteArrayList에서 쓰인다.
        
- 프록시 패턴 구조
    
    ![images-ha0kim-post-35b457ec-be2d-4f31-89f9-74fc3b334390-image.png](%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%209cd9c808e59747b590d180d5864f679e/images-ha0kim-post-35b457ec-be2d-4f31-89f9-74fc3b334390-image.png)
    
    1. Subject
        - Proxy 와 RealSubject가 구현해야하는 인터페이스.
        - 두 객체를 동일하게 다루기 위해 존재한다.
    2. Proxy
        - RealSubect 와 Client 요청 사이에 존재하는 객체.
        - Subject를 구현함으로써 클라이언트는 RealSubject 사용하는 것과 별 차이가 없어야 한다.
    3. RealSubject
        - 실질적으로 요청에 대해 주된 기능을 수행하는 객체.
        - Proxy 객체는 내부적으로 이 객체를 로직에 맞게 사용한다. (위임)

🔗 [https://velog.io/@ha0kim/Design-Pattern-구조-패턴Structural-Patterns](https://velog.io/@ha0kim/Design-Pattern-%EA%B5%AC%EC%A1%B0-%ED%8C%A8%ED%84%B4Structural-Patterns) 

🔗 [https://arabiannight.tistory.com/129](https://arabiannight.tistory.com/129)