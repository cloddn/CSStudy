# 행위 패턴

태그: 디자인 패턴
부가 태그: 정처기

## #행위패턴 Behavioral Patterns

> 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
> 
> 
> 한 객체가 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하여 객체 사이의 결합도 최소화에 중점을 둠
> 
> 패턴을 주로 클래스에 적용하는 지, 객체에 적용하는지에 따라 구분되는 패턴임
> 

## **📌 행위 패턴의 종류**

1. 책임연쇄 패턴(Chain of responsibility)
    - 책임들이 연결되어 있어 내가 책임을 못 질 것 같으면 다음 책임자에게 자동으로 넘어가는 구조이다.
2. 커맨드 패턴(Command Pattern)
    - 명령어를 각각 구현하는 것보다는 하나의 추상 클래스에 메서드를 하나 만들고 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행한다.
3. 인터프리터 패턴(Interpreter Pattern)
    - 문법 규칙을 클래스화한 구조를 갖는 SQL 언어나 통신 프로토콜 같은 것을 개발할 때 사용한다.
4. 이터레이터 패턴 (Iterator Pattern)
    - 반복이 필요한 자료구조를 모두 동일한 인터페이스를 통해 접근할 수 있도록 메서드를 이용해 자료구조를 활용할 수 있도록 해준다.
5. 옵저버 패턴(Observer Pattern)
    - 어떤 클래스에 변화가 일어났을 때, 이를 감지하여 다른 클래스에 통보해준다.
6. 전략 패턴 (Strategy Pattern)
    - 알고리즘 군을 정의하고 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 해준다.
7. 템플릿 메서드 패턴 (Template method pattern)
    - 상위 클래스에서는 추상적으로 표현하고 그 구체적인 내용은 하위 클래스에서 결정된다.
8. 방문자 패턴 (visitor Pattern)
    - 각 클래스의 데이터 구조로부터 처리 기능을 분리하여 별도의 visitor 클래스로 만들어놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행한다.
9. 중재자 패턴 (Mediator Pattern)
    - 클래스간의 복잡한 상호작용을 캡슐화하여 한 클래스에 위임해서 처리한다.
10. 상태 패턴 (State Pattern)
    - 동일한 동작을 객체의 상태에 따라 다르게 처리해야 할 때 사용한다.
11. 기념품 패턴 (Memento Pattern)
    - Ctrl + z 와 같은 undo 기능 개발할 때 유용한 디자인패턴. 클래스 설계 관점에서 객체의 정보를 저장한다.

### **✔ (1) 행위 패턴 - 책임 연쇄 패턴(Chain of responsibility)**

- 책임 연쇄 패턴이란?
    - 클라이언트 요청을 처리할 수 있는 처리 객체를 집합(Chain)으로 만들어 부여함으로 → 결합을 느슨하게 하기 위해 만들어진 디자인 패턴
    - 실제 많이 쓰이는 패턴 중 하나임, **여러개의 객체중 어떤 것이 요구를 처리할 수 있는 지 사전에 알 수 없을때 사용**됨 `( 여러개이고 , 처리객체가 특정적이지 않을 경우 사용 !)`
    - 요청 처리가 들어오게 되면 그것을 수신하는 객체가 자신이 처리할 수 없는 경우에는 다음 객체에게 문제를 넘김으로서 최종적으로 요청을 처리할 수 있는 객체에 의해 처리가 가능하도록 하는 패턴
- 책임 연쇄 패턴이 적용되는 경우
    1. 요청의 발신자와 수신자를 분리하는 경우
    2. 요청을 처리할 수 있는 객체가 여러개일 때 그 중 하나에 요청을 보내려는 경우
    3. 코드에서 처리객체(handler)를 명시적으로 지정하고 싶지 않은 경우
- ✏️ 책임 연쇄 패턴 장점과 단점
    - 책임연쇄 패턴 장점
    1. 결합도를 낮추며, 요청의 발신자와 수신자를 분리시킬 수 있다.
    2. 클라이언트는 처리객체의 집합 내부의 구조를 알 필요가 없다.
    3. 집합 내의 처리 순서를 변경하거나 처리객체를 추가 또는 삭제할 수 있어 유연성이 향상된다.
    4. 새로운 요청에 대한 처리객체 생성이 매우 편리하다.
    - 책임연쇄 패턴 단점
    1. 충분한 디버깅을 거치지 않았을 경우 집합 내부에서 사이클이 발생할 수 있다.
    2. 디버깅 및 테스트가 쉽지 않다.
- 책임 연쇄 패턴 구조
    
    ![images-ha0kim-post-e6a202e6-be0a-49ce-9a69-4d9e815ca8df-image.png](%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8B%E1%85%B1%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%208fe9b779fbe7433b84b017bc76493601/images-ha0kim-post-e6a202e6-be0a-49ce-9a69-4d9e815ca8df-image.png)
    
    1. Handler
        
        요청을 수신하고 처리객체들의 집합에 전달하는 인터페이스이다.
        
        집합의 첫 번째 핸들러에 대한 정보만 가지고 있으며 그 이후의 핸들러에 대해서는 알 수 없다.
        
    2. Concrete Handler
        
        요청을 처리하는 실제 처리객체입니다.
        
    3. Client
        
        요청을 전달하는 클라이언트입니다.
        

### **✔ (2) 행위 패턴 - 커맨드 패턴(Command Pattern)**

- 커맨트 패턴이란?
    - 해당 요청에 따라야 하는 기능들을 캡슐화한 객체에 정리하여 실행할 수 있게 해주는 디자인 패턴
    - 즉, 요청에 따르는 기능들이 다양하고 변경 및 추가 삭제가 많은 경우 요청이 발생되는 클래스를 변경하지 않고 수정할때 매우 유용함
- 커맨드 패턴이 사용되는 경우
    1. 병렬 처리 (Parallel Processing) :병렬로 여러 스레드에서 실행이 되어야하는 경우
    2. 매크로(Macro) : 특정 명령에 따른 동일한 일련의 작업을 반복적으로 수행해야 하는 경우
    3. 네트워킹(Networking) : 네트워크를 통해 일련의 작업을 보내야하는 경우(원격조작, 게임 캐릭터에 명령)
- ✏️ 커맨드 패턴의 장단점
    - 커맨드 패턴 장점
        1. 기존 코드를 변경하지 않고 새 명령을 추가할 수 있어 코드확장이 수월하다.
        2. 호출자(invoker)와 수신자(receiver)의 결합도를 낮출 수 있다.
    - 커맨드 패턴 단점
        1. 1. 개별 명령에 대한 클래스의 수가 증가할 수 있다.

- 커맨드 패턴 구조
    
    ![images-ha0kim-post-74b91a68-ff51-4afc-b607-4d29ee4461aa-image-2.png](%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8B%E1%85%B1%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%208fe9b779fbe7433b84b017bc76493601/images-ha0kim-post-74b91a68-ff51-4afc-b607-4d29ee4461aa-image-2.png)
    
    1. Invoker
        
        해당 요청에 따르는 기능의 실행을 요청하는 호출자 클래스이다.
        
    2. Command
        
        실행될 기능에 대한 인터페이스.
        
        실행되는 기능들을 종합하는 execute를 선언한다.
        
    3. ConcreteCommand
        
        실제로 실행되는 기능을 구현한다.
        
    4. Receiver
        
        ConcreteCommand의 execute를 구현하는 클래스.
        
        기능을 실행하기 위해 필요한 수신자 클래스이다.
        
    5. Client
        
        요청을 전달하는 클라이언트이다.
        

### **✔ (3) 행위 패턴 - 인터프리터 패턴(Interpreter Pattern)**

- 인터프리터 패턴이란
    - 언어 문법이나 표현을 평가할 수있는 방법을 제공한다.
    - 이 패턴은 특정 컨텍스트를 해석하도록 지시하는 표현 인터페이스를 구현하는 것을 포함
    - 이 패턴은 SQL 구문 분석, 기호 처리 엔진 등에서 사용됨.
- 인터프리터 패턴 구조
    
    ![images-ha0kim-post-c2e5abd8-e50e-4aac-b999-e5035bce39e0-image.png](%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8B%E1%85%B1%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%208fe9b779fbe7433b84b017bc76493601/images-ha0kim-post-c2e5abd8-e50e-4aac-b999-e5035bce39e0-image.png)
    
1. AbstractExpression : interpret()를 정의한다.
2. TerminalExpression : interpret()를 구현한다.
3. NonTerminalExpression : Non-Terminal의 interpret()를 구현한다.
4. Context : String 표현식이어야 하며 인터프리터에 보내는 정보이다.
5. Client : interpret()를 호출한다.

### **✔ (4) 행위 패턴 - 이터레이터 패턴(Iterator Pattern)**

- 이터레이터 패턴이란?
    - 반복하다라는 의미로 , 어떠한 객체의 집합을 순서대로 명령을 처리할 수 있게 해주는 디자인 패턴임
    - 컬렉션 구현 방법을 노출시키지않으면서도 그 집합체 안에 들어 있는 모든 항목에 접근할 수 있게 해주는 방법을 제공해주는 패턴 → 간단하면서도 실제로 굉장히 많이 쓰고 있는 패턴
    - 즉, for 문에서 i의 역할을 추상화하고 일반화한 것
- 이터레이터 패턴 구조
    
    ![images-ha0kim-post-90d8ad52-1657-4e0d-b51d-24c694b6f90e-image.png](%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8B%E1%85%B1%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%208fe9b779fbe7433b84b017bc76493601/images-ha0kim-post-90d8ad52-1657-4e0d-b51d-24c694b6f90e-image.png)
    
    1. Iterator : 순서대로 객체를 검색하는 인터페이스를 정한다.
    2. ConcreateIterator : Iterator에서의 인터페이스를 구현한다.
    3. Aggregate : Iterator의 역할을 만드는 인터페이스를 정한다.
    4. ConcreateAggreagate : Aggregate에서의 인터페이스를 구현한다.

### **✔ (5) 행위 패턴 - 옵저버 패턴(Observer Pattern)**

- 옵저버 패턴이란?
    - 객체의 상태 변화를 관찰하는 관찰자 객체를 생성하여 사용하는 디자인 패턴
    - 즉, 객체의 변화가 발생하면 그에 따르는 종속 개체들이 자동으로 변화가 통지되어 그에 따른 명령을 수행하도록 하는 일대다의 의존성을 정의함
    - 데이터의 변경이 발생했을 경우 상대 클래스나 객체에 의존하지 않으면서 데이터 변경을 통보하고자 할때 유용함
    - **`예시)`**
        - 새로운 파일이 추가되거나 기존 파일이 삭제되었을 때 탐색기는 다른 탐색기에게 즉시 변경을 통보해야함
        - 차량 연료량 클래스는 연료량이 부족한 경우 연료량에 관심을 가지는 구체적인 클래스(연료량 부족 경고 클래스, 주행 가능 거리 출력 클래스)에 직접 의존하지 않는 방식으로 연료량 변화를 통보해야 한다.
    - ✏️ **`옵저버 패턴을 사용하는 경우`**
        1. 분산 이벤트 핸들링 시스템
        2. 이벤트 기반 프로그래밍
    - ✏️ 옵저버 패턴 장점
        1. 객체간의 결합도가 느슨해진다.
        2. 실시간으로 효과적으로 데이터를 배분할 수 있다.
    - 옵저버 패턴 구조
        
        ![images-ha0kim-post-979e49c7-b93a-48f2-91db-d96efa47dfcc-image.png](%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8B%E1%85%B1%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%208fe9b779fbe7433b84b017bc76493601/images-ha0kim-post-979e49c7-b93a-48f2-91db-d96efa47dfcc-image.png)
        
        1. Observer
            
            데이터의 변경을 통보 받는 인터페이스
            
            즉, Subject에서는 Observer 인터페이스의 update 메서드를 호출함으로써 ConcreteSubject의 데이터 변경을 ConcreteObserver에게 통보한다.
            
        2. Subject
            
            ConcreteObserver 객체를 관리하는 요소
            
            Observer 인터페이스를 참조해서 ConcreteObserver를 관리하므로 ConcreteObserver의 변화에 독립적일 수 있다.
            
        3. ConcreteSubject
            
            변경 관리 대상이 되는 데이터가 있는 클래스(통보하는 클래스)
            
            데이터 변경을 위한 메서드인 setState가 있다.
            
            setState 메서드에서는 자신의 데이터인 subjectState를 변경하고 Subject의 notifyObservers 메서드를 호출해서 ConcreteObserver 객체에 변경을 통보한다.
            
        4. ConcreteObserver
            
            ConcreteSubject의 변경을 통보받는 클래스
            
            Observer 인터페이스의 update 메서드를 구현함으로써 변경을 통보받는다.
            
            변경된 데이터는 ConcreteSubject의 getState 메서드를 호출함으로써 변경을 조회한다.
            
    
    ### **✔ (6) 행위 패턴 - 전략 패턴(Strategy Pattern)**
    
    - 전략 패턴
        - 행위를 클래스로 캡슐화해 동적으로 행위를 바꿀 수 있게 해주는 패턴으로 같은 문제를 해결하는 여러 알고리즘이 클래스별로 캡슐화되어있고 이들이 필요할때 교체할 수 있도록 함으로서 동일한 문제를 다른 알고리즘으로 해결할 수 있게 해주는 디자인 패턴
        - 즉, 전략을 쉽게 바꿀 수 있게 해주는 디자인 패턴
            
            <aside>
            ✏️ 전략이란?
            
            - 어떤 목적을 달성하기 위해 일을 수행하는 방식, 비즈니스 규칙, 문제를 해결하는 알고리즘 등
            - 특히 게임 프로그래밍에서 게임 캐릭터가 자신이 처한 상황에 따라 공격이나 행동하는 방식을 바꾸고 싶을때 사용할경우 매우 유용함
            </aside>
            
    - ✏️ **`전략 패턴 장점`**
        1. 시스템의 구조 및 Context Class를 변경하지 않고 요청에 맞는 로직을 추가 및 수정할 수 있다.
        2. 같은 인터페이스 양식을 가진 알고리즘을 별도로 캡슐화하여 코드의 가독성이 높아지며, 생산성이 높아진다.
        3. 요청에 맞는 로직을 실시간으로 변경할 수 있다.
    - 전략 패턴 구조
        
        ![images-ha0kim-post-980e92a6-14a7-4f31-8dcf-7244549f8c17-image.png](%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8B%E1%85%B1%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%208fe9b779fbe7433b84b017bc76493601/images-ha0kim-post-980e92a6-14a7-4f31-8dcf-7244549f8c17-image.png)
        
1. Strategy
    
    인터페이스나 추상 클래스로 외부에서 동일한 방식으로 알고리즘을 호출하는 방법을 명시한다.
    
2. ConcreteStrategy
    
    스트래티지 패턴에서 명시한 알고리즘을 실제로 구현한 클래스이다.
    
3. Context
    
    스트래티지 패턴을 이용하는 역할을 수행한다.
    
    필요에 따라 동적으로 구체적인 전략을 바꿀 수 있도록 setter 메서드(‘집약 관계’)를 제공한다.
    

### **✔ (7) 행위패턴 - 템플릿 메서드 패턴( Template method Pattern)**

- 개념
    - 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화하여 전체 일을 수행하는 구조는 바꾸지 않으면서, 특정 단계에서 수행하는 내역을 바꾸는 패턴
        - 즉, **전체적으로 동일**하면서, **부분적으로는 다른 구문으로 구성된 메서드의 코드 중복**을 최소화할 때 유용함
        - 다른 관점에서 볼경우, 동일한 기능을 상위 클래스에서 정의하면서 확장 및 변화가 필요한 부분만 서브클래스에서 구현할 수 있도록 함
        - 예시) 전체적인 알고리즘은 상위 클래스에서 구현하고, 다른 부분들은 하위 클래스에서 구현할 수 있도록 함으로서 전체적인 알고리즘 코드를 재사용하는데에 유용함
- 역할이 수행하는 작업
    - Abstract Class
        - 템플릿 메서드를 정의하는 클래스
        - 하위 클래스에 공통 알고리즘을 정의하고, 하위 클래스에서 구현될 기능을 primitive 메서드 또는 hook 메서드로 정의함
    - ConcreteClass
        - 물려받은 primitive 메서드 또는 hook 메서드를 구현하는 클래스
        - 상위 클래스에 구현된 템플릿 메서드의 일반적인 알고리즘에서 하위 클래스에 적합하게 primitive 메서드나 hook 메서드를 오버라이드하는 클래스
        - 예시) 여러 회사의 모터 지원하기
    
    ![template-method-pattern.png](%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8B%E1%85%B1%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%208fe9b779fbe7433b84b017bc76493601/template-method-pattern.png)
    

### **✔ (8) 행위패턴 - 방문자 패턴( Visitor  Pattern)**

- 방문자 패턴이란?
    - 실제 로직을 가지고 있는 객체 (Visitor)가 로직을 적용할 객체 (Element)를 방문하면서 실행하는 패턴임
    - 즉, 로직과 구조를 분리하는 패턴
    - 로직과 구조가 분리되면 구조를 수정하지 않고 새로운 동작을 기존 객체 구조에 추가할 수 있음
    - 비슷한 종류의 객체들을 가진 그룹에서 작업을 수행해야 할때 주로 사용되는 패턴
- 방문자 패턴구조
    
    ![images-ha0kim-post-22dbfb53-86da-4225-b85f-ce8a67cc7af0-image.png](%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8B%E1%85%B1%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%208fe9b779fbe7433b84b017bc76493601/images-ha0kim-post-22dbfb53-86da-4225-b85f-ce8a67cc7af0-image.png)
    
1. Visitor
    
    명령을 수행하기 위해 필요한 메소드를 정의하는 인터페이스이다.
    
2. ConcreteVisitor
    
    명령을 수행하는 메소드를 구현한다.
    
3. Element
    
    Visit를 사용할 수 있는지 확인하는 accept 메소드를 정의하는 인터페이스이다.
    
4. ConcreteElement
    
    Visitable에서 정의된 accept 메소드를 구현하며 Visitor객체는 이 객체를 통하여 명령이 전달된다.
    

### **✔ (9) 행위패턴 - 중재자 패턴( Mediator  Pattern)**

- 중재자 패턴?
    - 객체들 간의 상호작용 행위를 정리하여 모은 중재자 객체를 따로 두어 관리하는 디자인 패턴
    - 모든 클래스 간의 복잡한 로직 (상호작용)을 캡슐화하여 하나의 클래스에 위임하여 처리하는 패턴
    - 즉, M:N의 관계에서 M:1의 관계로 복잡도를 떨어트려 유지 보수 및 재사용의 확장성에 유리한 패턴
    - 커뮤니케이션을 하고자하는 객체가 있을때 서로가 커뮤니케이션하기 복잡한 경우 이를 해결해주고 서로 간 쉽게 해주며 커플링을 약화시켜주는 패턴임
    - 객체들간 커뮤니케이션 정의가 있지만, 복잡할 때 (종합이 필요할때) 사용함
- ✏️ 중재자 패턴이 사용되는 경우
    - 객체들간의 관계가 매우 복잡하여 객체의 재사용에 부담이 갈 경우
- ✏️ 중재자 패턴 장점
    1. 객체들 간 수정하지 않고 관계를 수정할 수 있음
    2. 객체 들간의 관계의 복잡도, 의존성 및 결합도를 감소시킴
- 중재자 패턴 구조
    
    ![images-ha0kim-post-5a2aa9b3-504e-446e-80a5-ce4835d6004d-image.png](%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8B%E1%85%B1%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%208fe9b779fbe7433b84b017bc76493601/images-ha0kim-post-5a2aa9b3-504e-446e-80a5-ce4835d6004d-image.png)
    
    1. Mediator
        
        Colleague 객체간의 상호작용을 위한 인터페이스를 정의한다.
        
    2. ConcreteMediator
        
        Mediator의 인터페이스를 구현하여 객체간의 상호작용을 조정한다.
        
    3. Colleague
        
        다른 Colleague와의 상호작용을 위한 인터페이스를 정의한다.
        
    4. ConcreteColleague
        
        Colleague의 인터페이스를 구현하며 Mediator를 통해 다른 Colleague와 상호작용한다.
        

### **✔ (10) 행위패턴 - 상태 패턴( State  Pattern)**

- 상태 패턴
    - 상태 디자인 패턴 : 객체 내부의 상태에 따라 동작을 변경해야할때 사용하는 디자인 패턴
    - 객체의 특정 상태를 클래스로 선언하고 클래스에서는 해당 상태에서 할 수 있는 행위들을 메서드로 정의함
    - 각 상태 클래스들을 인터페이스로 캡슐화하여 클라이언트에서 인터페이스를 호출함
- ✏️ `상태 패턴 장점`
    1. 하나의 객체에 대한 여러 동작을 구현해야할 때 상태 객체만 수정하므로 동작의 추가, 삭제 및 수정이 간단하다.
    2. State 패턴을 사용하면 객체의 상태에 따른 조건문(if/else, switch)이 줄어들어 코드가 간결해지고 가독성이 올라간다.
- 상태 패턴 구조
    
    ![images-ha0kim-post-c2dbf4ab-713f-46b0-8aa5-e2a3e98e8cf9-image.png](%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8B%E1%85%B1%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%208fe9b779fbe7433b84b017bc76493601/images-ha0kim-post-c2dbf4ab-713f-46b0-8aa5-e2a3e98e8cf9-image.png)
    
    1. Context
        
        객체의 상태를 정의하는 데 사용되는 메소드를 정의하는 인터페이스이다.
        
    2. State
        
        상태에 따른 동작을 정의하는 인터페이스이다.
        
    3. ConcreteState
        
        State에서 정의된 메소드를 구현하는 클래스이다.
        

### **✔ (11) 행위패턴 - 기념품 (메멘토) 패턴( Memento  Pattern)**

- 기념품 패턴이란?
    - 객체의 상태 정보를 가지는 클래스를 따로 생성하여 객체의 상태를 저장하거나 이전 상태로 복원할 수 있도록 해주는 패턴
    - 바둑, 오목, 체스 등의 보드게임 등에서 “무르기”기능을 구현할때 사용됨
    - 단, 이전 상태의 객체를 저장하기 위한 Originator가 클 경우 많은 메모리가 필요함!
- 기념품 패턴 구조
    
    ![images-ha0kim-post-1e8edc32-2e1b-4e78-8427-c5de24f3e0ac-image.png](%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8B%E1%85%B1%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%208fe9b779fbe7433b84b017bc76493601/images-ha0kim-post-1e8edc32-2e1b-4e78-8427-c5de24f3e0ac-image.png)
    
    1. Originator
        
        객체의 상태를 저장한다.
        
        Memento 객체를 생성하며 후에 Memento를 사용하여 실행 취소(undo)를 할 수 있다.
        
    2. Memento
        
        Originator의 상태를 유지하는 객체이다.(POJO)
        
    3. Caretaker
        
        마치 게임의 세이브포인트처럼 복수의 Memento의 상태를 유지해주는 객체이다.
        

🔗 [https://velog.io/@ha0kim/Design-Pattern-행동-패턴Behavioral-Patterns](https://velog.io/@ha0kim/Design-Pattern-%ED%96%89%EB%8F%99-%ED%8C%A8%ED%84%B4Behavioral-Patterns)

🔗 [https://velog.io/@ha0kim/Design-Pattern-행동-패턴Behavioral-Patterns-2](https://velog.io/@ha0kim/Design-Pattern-%ED%96%89%EB%8F%99-%ED%8C%A8%ED%84%B4Behavioral-Patterns-2)