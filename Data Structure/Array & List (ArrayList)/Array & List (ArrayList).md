# Array & List (ArrayList)

태그: 자료구조

## **📌** 배열 Array

- **`선언시 반드시 그 크기를 지정해야함.`**
- 데이터가 많아지고 **그룹관리의 필요**에 따라 배열을 사용
- **고정된** 크기를 갖는 **같은 자료형**의 원소들이 **연속적인** ( 논리적 저장 순서와 물리적 저장 순서가 일치) 형태로 구성된 자료 구조
    - 인덱스에 따라 값을 유지하므로 원소가 삭제되어도 빈자리가 남게 되어 메모리가 낭비됨
    - 처음 크기를 10으로 지정하면, 5개의 데이터만 저장하더라도 실제 배열의 크기 10 - `정적인 크기의 데이터를 다룰 때에 적합함, 계속해서 늘어나거나 바뀌는 경우엔 적합하지 않음.`
        
        ```java
        int array1[5];
        string array2[10];
        ```
        
- `**인덱스 index**` : 각 원소의 번호로 0번부터 시작하며, 해당 원소에 접근
- 데이터 갯수가 확실하게 정해져있고, 접근이 빈번한 경우 배열이 효율적임
- **`cache hit` 가능성이 커져 성능에 큰 도움이 됨**
    - cache hit: CPU가 참조하고자 하는 메모리가 캐시에 존재하고 있는 경우
- 고정적이고 연속적인 만큼, 인덱스로 random access가 가능함
    - 접근, 수정 : O(1)으로 빠르게 조회가 가능함
    - 하지만 삽입과 삭제의 경우, 연속적인 형태를 유지하기 위해 Shift 연산을 해야하므로 O(n)

 

## ****📌 리스트(List)****

- 배열의 문제점을 해결하기 위한 자료구조
- 빈틈없는 데이터의 적재라는 장점!
    - 원소를 삭제시, 삭제된 데이터 뒤에 원소로 빈틈없이 연속적으로 위치시킴
- 리스트의 핵심 : 원소들 간, **순서가 있는 데이터의 모임, 다른 이름으로는 시퀀스 (Sequence)라고 함**
- 배열에서 인덱스는 유일무이한 식별자이지만, 리스트는 몇번째 데이터인지 정도의 의미를 가짐
- 빈 엘리먼트 X
- 순차성을 보장하지 못하기때문에, Spacial locality 보장이 되지않아서, cash hit가 어렵다
    - spacial locality : 프로그램 실행시 접근하는 메모리 영역은 이미 접근이 이루어진 영역의 근처일 확률이 높다는 프로그램 성격 표현
- 언어별로 list로 지원하는 것이 다름
    - C : 지원 X
    - JavaScript : 배열에 리스트 기능 포함
    - Python : 기본 리스트 , 배열 지원 X
    - Java : 배열과 리스트 모두 지원, ArrayList, Linked List로 나뉨

<aside>
💡 ArrayList와 LinkedList는 구현 방법에 따라 나뉜다

- ArrayList
    - 배열을 이용해 리스트로 구현함
    - 접근이 빠름 (순차X) , 하지만 데이터 추가와 삭제가 느림
    - 동적으로 사용하기 힘듬 - 자바의 경우 자동으로 사이즈를 키워서 관리함 → Dynamic Array
- LinkedList
    - 연결로 구현한 리스트
    - 한 원소에서 값과 다음 원소의 주소를 알고 연결하는 방식
    - 순차적으로 접근함 O(n)
    - 삽입, 삭제는 O(1)이지만 해당 지점까지 접근해야하므로 O(n)일 수 있음
        
        → 배열과 다르게 논리적 저장 순서와 물리적 저장 순서가 일치하지 않음
        
</aside>

**✔ 배열은 Compile time에 할당되는 정적 메모리 할당, 리스트는 새로운 Node가 추가되는 runtime에 할당되는 동적 메모리 할당**

- 런타임 : 컴파일 과정을 마친 응용 프로그램이 사용자에 의해 실행될 때
- 컴파일 타임 : 소스코드가 컴파일을 통해 기계어 코드로 변환되어 실행 가능한 프로그램이 되는 편집 과정

### **📌 배열 리스트 ArrayList**

- 크기를 정해주지 않아도 되는 가변적으로 크기가 변하는 선형 리스트
- 배열과 동일하게 순차리스트, index를 이용해 내부의 객체를 관리하지만, ArrayList는 데이터가 추가되어 저장 용량을 초과하면 자동으로 부족한 만큼 용량을 늘림
    
    ![스크린샷 2023-07-21 오전 11.00.51.png](Array%20&%20List%20(ArrayList)%208f335babf42e47bf81a0dffbcb12faf0/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-07-21_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%258C%25E1%2585%25A5%25E1%2586%25AB_11.00.51.png)
    
- 요소를 추가하면 index 0부터 차례대로 저장됨
- 중간의 특정 index에 데이터를 추가하거나 삭제하면 index이후에 위치한 데이터를 모두 한칸씩 앞뒤로 옮겨주어야 해 비효율적임
- 데이터의 크기가 가변적이고 중간에 데이터를 삽입한다거나, 삭제하는 경우가 거의 없는 경우에 적절함

🔗 [https://velog.io/@nnnyeong/자료구조-배열-Array-배열-리스트-ArrayList-연결-리스트-LinkedList](https://velog.io/@nnnyeong/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%B0%B0%EC%97%B4-Array-%EB%B0%B0%EC%97%B4-%EB%A6%AC%EC%8A%A4%ED%8A%B8-ArrayList-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8-LinkedList)

🔗 [https://jy-tblog.tistory.com/38](https://jy-tblog.tistory.com/38)