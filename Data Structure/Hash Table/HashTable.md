# HashTable

태그: 자료구조

**📌✔**

## 해싱이란? Hashing

- 임의의 길이의 값을 해시 함수 (Hash Function)을 사용하여 고정된 크기의 값으로 변환하는 작업을 말함
    
    ![스크린샷 2023-07-23 오후 9.08.19.png](HashTable%20bf3edd85c5ff45b79cf236fe3de25d92/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-07-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.08.19.png)
    
- dog이라는 문자열을 해시함수를 이용해 새로운 값으로 변환 (해시 알고리즘 : MD5 사용)
- 해싱을 사용하여 데이터를 저장하는 자료구조를 해시 테이블이라고 함
    - 기존 자료구조인 이진 탐색 트리나, 배열에 비해서 굉장히 빠른 속도로 탐색, 삽입, 삭제 가능

## **📌** 해시 테이블

- 해시 함수를 사용하여 변환한 값을 색인(index)으로 삼아 키(key)와 데이터(value)를 저장하는 자료구조
    - 기본연산: 탐색(Search), 삽입(Insert), 삭제(Delete)

### (1) Direct Address Table

- 가장 간단한 형태의 해시 테이블 : 키 - 값을 주소 사용하는 테이블
    - 키 값이 100이라고 했을때 배열의 인덱스 100에 원하는 데이터를 저장하는 것
        
        ![스크린샷 2023-07-23 오후 9.22.35.png](HashTable%20bf3edd85c5ff45b79cf236fe3de25d92/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-07-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.22.35.png)
        
    - 위 그림에선 키 값이 21이므로 인덱스 21에 원하는 데이터를 저장한 경우
    - 탐색, 삽입, 삭제 연산을 모두 O(1)에 할 수 있음
    - 한계점
        - 최대 키값에 대해 알고 있어야함
        - 최대 키 값이 작을때 실용적으로 사용 가능
        - 키 값들이 골고루 분포되어있지 않다면 메모리 낭비가 심할 수 밖에 없음

### (2) Hash Table

![스크린샷 2023-07-23 오후 9.48.48.png](HashTable%20bf3edd85c5ff45b79cf236fe3de25d92/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-07-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.48.48.png)

**✔ 해시 함수를 사용하여 특정 해시값을 알아내고 그 해시 값을 인덱스로 변환하여 키 값과 데이터를 저장하는 자료구조**

- 충돌 Collision
    - 적재율 (Load Factor) : 해시 테이블의 크기 대비, 키의 갯수를 말함
    - 즉 키의 갯수 K, 해시 테이블의 크기 N이라고 했을때 적재율은 K/N
        - Direct Address Table : 키 값을 인덱스로 사용하는 구조이므로 적재율이 1이하이며 적재율이 1초과인 해시 테이블은 반드시 충돌이 발생함
        - 충돌 발생시엔 탐색, 삭제 연산이 최악에 O(K)만큼 소요됨
            
            = 같은 인덱스에 모든 키값과 데이터가 저장된 경우로 충돌이 전부 발생했음을 말함
            
            - 따라서, 충돌을 최대한으로 줄여서 연산 속도를 빠르게 하는 것이 해시 테이블의 핵심
            - 이에 중요하게 작용하는 것 = 해시함수를 구현하는 `해시 알고리즘`!
                
                해시 알고리즘이 견고하지 못하면 해시함수로 도출된 값들이 같은 경우가 빈번하게 발생하므로 잦은 충돌이 이어지게 됨
                
    
    **✔** 충돌을 완화 하는 방법
    
    - 해시 테이블의 구조 개선
    - 해시 함수 개선
    
    ### 충돌 해결 1: 해시 테이블의 구조 개선
    
    > **✔  `1. Chaining`**
    > 
    
    ![스크린샷 2023-07-23 오후 9.53.05.png](HashTable%20bf3edd85c5ff45b79cf236fe3de25d92/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-07-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.53.05.png)
    
    - 충돌이 발생했을 때, 동일한 버킷(Bucket)에 저장하는데 이를 연결 리스트 형태로 저장하는 방법
    - John Smith와 Sandra Dee의 인덱스가 152로 충돌하게 된 경우, 이때 Sandra Dee를 John Smith 뒤에 연결함으로써 충돌을 처리하는 것을 알 수 있음
    
    - 체이닝을 통해 해시 테이블을 구현했을 때의 시간 복잡도는 어떻게 될까? 삽입의 경우 연결리스트에 추가하기만 하면 되므로, 상수 시간인 O(1)이 걸리지만, 탐색과 삭제의 경우 최악일때 키 값의 갯수인 K → O(K)가 걸리게 됨
        - 시간복잡도를 적재율을 이용해서 평균으로 표현하는 것이 일반적
        - 적재율를 K/N이라고 하면 즉 해시 테이블 내의 공간 대비 값들이 얼마나 있느나, 즉 충돌할 여지가 얼마나 있느냐의 뜻임
            - 시간복잡도에 적용하면 O (K/N +1)이라고 함.
            - 정확한 증명은 찾을 수 없었다고함…
    
    > **✔  `2. Open Addressing`**
    > 
    - 원래라면 해시 함수로 얻은 해시값에 따라 데이터와 키값을 저장하지만, 동일한 주소에 다른 데이터가 있을 경우 다른 주소도 이용할 수 있게 하는 기법임
        
        ![스크린샷 2023-07-23 오후 9.58.06.png](HashTable%20bf3edd85c5ff45b79cf236fe3de25d92/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-07-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.58.06.png)
        
    - 동일한 충돌에 대해 체이닝을 적용하지 않고, 그 다음으로 비어있는 주소인 153에 저장하는 것을 알 수 있음
    - 삽입: 계산한 해시 값에 대한 인덱스가 이미 차있는 경우 다음 인덱스로 이동하면서 비어있는 곳에 저장
        - 비어있는 자리를 탐색하는 것 = 탐사 (Probing)이라고함
    - 탐색: 계산한 해시 값에 대한 인덱스부터 검사하며 탐사를 해나가는데, 이때 “삭제”표시가 있는 부분은 지나감
    - 삭제 : 탐색을 통해 해당 값을 찾고 삭제한 뒤 “삭제" 표시를 함
    
    - 이러한 open addressing방식은 3가지 방법을 통해 충돌을 처리함
        1. 선형 탐사
            
            ![스크린샷 2023-07-23 오후 10.02.03.png](HashTable%20bf3edd85c5ff45b79cf236fe3de25d92/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-07-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.02.03.png)
            
            - 가장 기본적인 충돌 해결 기법
            - 바로 인접한 인덱스에 데이터를 삽입해가기때문에 데이터가 밀집되는 클러스터링 (Clustering)문제가 발생하고 이로 인해 탐색과 삭제가 느려지게 됨
            
        2. 제곱 탐사
            
            ![스크린샷 2023-07-23 오후 10.02.10.png](HashTable%20bf3edd85c5ff45b79cf236fe3de25d92/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-07-23_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_10.02.10.png)
            
            - 제곱수로 탐사를 하는 방식으로 선형 탐사에 비해 더 폭넓게 탐사하기때문에 탐색과 삭제에 효율적일수 있음
            - 초기 해시값이 같을 경우에 탐사하는 역시나 클러스터링 문제가 발생
            
        3. 이중 해싱
            - 해시 함수로는 해시 값을 찾기 위해 사용, 두번째 해시 함수는 충돌이 발생했을 때 탐사 폭을 계산하기 위해 사용됨
    
    ### 충돌 해결 2: 해시 함수 개선
    
    > **✔ `1. 나눗셈 법`**
    > 
    - 아주 간단하게 해시 값을 구하는 방법
    - 미리 해시 테이블인 크기 N을 아는 경우에 사용가능
    - 해시 함수를 적용하고자 하는 값을 N으로 나눈 나머지를 해시 값으로 사용하는 방법
        - h(k)=k mod N
    
    > **✔ `2. 곱셈법`**
    > 
    

🔗 [https://baeharam.netlify.app/posts/data structure/hash-table](https://baeharam.netlify.app/posts/data%20structure/hash-table)