# 정렬 (2) - heap

태그: 알고리즘

## #힙정렬 heap sort

> 최대 힙 트리나 최소 힙 트리를 구성해 정렬하는 알고리즘
> 
- 힙 : 완전 이진 트리의 일종
    - 최솟값, 최댓값을 쉽게 추출할 수 있는 구조
- 배열로 최대힙을 구성한 뒤에 정렬하는 순서

### **📌 heap 정렬 순서**

```
1. n개의 노드에 대한 완전 이진 트리를 구성한다.
	루트를 기준으로 부모, 왼쪽 자식, 오른쪽 자식 순서대로 구성한다
2. 최대 힙을 구성한다. (max-heap)
	최대 힙이란 부모 노드가 자식 노드보다 큰 트리를 말한다.
3. 아랫부분의 작은 부분 트리부터 시작해 올라가는 방식 (bottom-up)으로 전체 배열을 최대힙으로 만든다.
4. 힙에서 가장 큰 값인 루트 노드와 배열의 가장 마지막 값과 바꾼다. = 마지막에 가장 큰 수가 루트노드의 값으로 정렬 * 루트노드= max_heap이므로 가장 큰값이 오기때문에
5. 다시 힙의 구조가 되도록 정리한다 = heapify
6. 4~5번 작업을 모든 숫자가 완료 상태가 될 때까지 반복한다

```

![Heapsort-example.gif](%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20(2)%20-%20heap%209accdeb88d9e438d9262ea619882ae7d/Heapsort-example.gif)

- ✏️ **실제 정렬 과정과 함께 알아보기~**
    
    `6 9 10 4 5 1 12 3` 
    
    해당 수가 있을때 수 들을 오름차순으로 정렬하는 힙정렬 해보기
    
    1. 완전 이진트리를 표현하기 위해 배열을 사용하여 데이터가 삽입되는 순서대로 배열의 인덱스를 정함
        - 인덱스 : 0 1 2 3 4 5 6 7
        - 데이터 : 6 9 10 4 5 1 12 3
        
        완전 이진 트리로 표현하기
        
        ![스크린샷 2023-08-02 오후 5.35.02.png](%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20(2)%20-%20heap%209accdeb88d9e438d9262ea619882ae7d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-08-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.35.02.png)
        
        표현된 완전이진트리를 힙 생성 알고리즘으로 최대 힙 구조로 바꾸기
        
        ![스크린샷 2023-08-02 오후 5.35.26.png](%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20(2)%20-%20heap%209accdeb88d9e438d9262ea619882ae7d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-08-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.35.26.png)
        
        12,3을 교환하고 12의 정렬을 확정 → 가장 큰 값 ( 루트 노드)
        
        ![스크린샷 2023-08-02 오후 5.36.10.png](%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20(2)%20-%20heap%209accdeb88d9e438d9262ea619882ae7d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-08-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.36.10.png)
        
        확정된 12를 제외한 나머지 노드를 다시 최대 힙의 구조로 재배열함
        
        ![스크린샷 2023-08-02 오후 5.36.19.png](%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF%20(2)%20-%20heap%209accdeb88d9e438d9262ea619882ae7d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-08-02_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.36.19.png)
        
        10과 6을 교환하고 10의 정렬을 확정함
        
        확정된 10를 제외한 나머지 노드들을 다시 최대 힙 구조로 배열함 
        
        → 해당 과정들을 계속 반복할 경우 , 트리의 리프 부분이 오름차순으로 정렬되며(확정되며) 확인할 수 있음!
        

- ✏️ **실제로  구현하여 알아보기~**
    
    ```python
    # 힙 정렬
    def heapify(unsorted, index, heap_size):
      largest = index
      left = 2 * index + 1
      right = 2 * index + 2
      
      if left < heap_size and unsorted[right] > unsorted[largest]:
        largest = left
        
      if right < heap_size and unsorted[right] > unsorted[largest]:
        largest = right
        
      if largest != index:
        unsorted[largest], unsorted[index] = unsorted[index], unsorted[largest]
        heapify(unsorted, largest, heap_size)
    
    def heap_sort(unsorted):
      n = len(unsorted)
      
      for i in range(n // 2 - 1, -1, -1):
        heapify(unsorted, i, n)
        
      for i in range(n - 1, 0, -1):
        unsorted[0], unsorted[i] = unsorted[i], unsorted[0]
        heapify(unsorted, 0, i)
    
      return unsorted
    ```
    

### **✔ heap 정렬 특징**

- **`장점`**
    - 시간 복잡도가 좋은 편
    - 힙 정렬이 유용한 경우는 전체 자료 정렬보다 가장 큰 값 몇개만 필요한 경우에 쓰임
- **`시간 복잡도`**
    - 이진 트리를 최대 힙으로 만들기 위하여 최대 힙으로 재구성하는 과정이 트리의 깊이만큼 필요함 **(힙 생성 알고리즘 시간 복잡도)**
        - **O(log n)**
    - 요소의 개수가 n개이므로 **O(nlogn)**의 시간 복잡도가 소요 **( 전체 데이터 수 = n)**
        - 힙 생성 알고리즘 시간 복잡도 X 전체 데이터 수 = O(NlogN)

🔗 [https://velog.io/@roro/자료구조알고리즘-퀵정렬-힙정렬-위상-정렬#02-힙정렬-heap-sort](https://velog.io/@roro/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%ED%80%B5%EC%A0%95%EB%A0%AC-%ED%9E%99%EC%A0%95%EB%A0%AC-%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC#02-%ED%9E%99%EC%A0%95%EB%A0%AC-heap-sort)

🔗 [https://yjg-lab.tistory.com/169](https://yjg-lab.tistory.com/169)

🔗 [https://good-potato.tistory.com/50](https://good-potato.tistory.com/50)